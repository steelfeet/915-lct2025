# Задача 10. Рабочий проект по определению координат по фотографии места
http://213.155.192.79:3005/ - демоверсия, работает в будние дни с 8:30 до 15:30, синхронизация БД раз в сутки

## Установка
### Виртуальное окружение
cd D:\_gogs\kladez_v2\
D:\_gogs\kladez_v2\myenv\Scripts\activate.ps1


### Настройка Alembic
cd D:\_gogs\kladez_v2\geo_osint_ml  
pip install alembic   
alembic init migration  

В файле alembic.ini указываем адрес базы:  
[alembic]  
...  
sqlalchemy.url = sqlite:///geo.db  

В файле migration/env.py импортируем все модели и указываем target_metadata:  
from geo_db import *   
target_metadata = Base.metadata   

Новые ревизии   
alembic revision --autogenerate -m 'initial'  
alembic upgrade head  


### Dagster
cd D:\_gogs\kladez_v2\geo_osint_ml\08-Parse-NER\geoosint  
dagit



### Файловая структура проекта
- admin: Flask веб-приложение админки и демоверсии;
- etl: ETL модули проекта;
    - parsers: парсеры открытых источников;
- ml_research: исследовательские модели, не обязательно ML; **TODO** - поправить пути для новой структуры каталогов
- migration: миграции Alembic (версии geoosint);
- presentation: презентации, как ни удивительно;
- vault.py - настройки хранения бинарных файлов (изображений, сканов литературы и т.п.);
- db.py - структура БД (примерная);


## Вариант №1. Классический. Классификация местности. / 01-GeoGuessr
Некий аналог классической GeoGuessr. Мы разбиваем интересующую область (г.Новозыбков в нашем случае) на квадраты со стороной 100 м. Каждый квадрат – это отдельный класс при классификации. Собираем ВСЕ фото из данной области в соответствии с классами и используем сверточные нейронные сети для задачи классификации. Мы брали MobileNet v.3. Полученная точность – 45% для 100 м. квадрата. К сожалению, для многих классов в нашем городе фотографий мало, поэтому возможно смещение точности. Также, субъективно, на точность влияют большое число изображений людей (домашние снимки, в кафе и т.д.), которые, возможно, использовались нейросетью как источник признаков.  

**parse_vk_2_classes.py** - парсинг ВК и разбиение на классы  
**geo.mobilenet.albu.teach.py** - обучение нейронной сети  
Epoch 12 | Train Acc: 35.150909 | Train Loss: 3.787234 | Valid Acc: 36.930202 | Valid Loss: 3.680733  
Epoch 55 | Train Acc: 86.229286 | Train Loss: 0.579765 | Valid Acc: 45.033325 | Valid Loss: 4.605267  

### Вариант №1.3 Классический. Классификация местности. Панорамы Yandex / 03-YaMap
В связи с их малочисленностью отдельно обучение не проводилось  




### 02-ClearDS - Вариант №1.2 Классический. Классификация местности. Панорамы Yandex + VK
Объединение датасетов №1 и №2. Но! Из изображений ВК берем только те, на которых есть архитектурные объекты или деревья / кустарники. Для их детекции используем AutoModelForZeroShotObjectDetection с моделью [IDEA-Research/grounding-dino-base](https://huggingface.co/docs/transformers/model_doc/grounding-dino).  

**detect_test.py** - подбор текстовых меток, которые характеризуют необходимые фотографии. Как видим, гораздо выгоднее детектировать каждую метку по отдельности, нежели одним промтом.  

**generate_classes.py, get_class.py** - генерация единых для всех вариантов классов GeoGuessr. Каждые 100 м.  

**check_panoram_classes.py** - посмотрим, сколько в среднем выбранных нами классов есть на реальных панорамах  
average_detected: 13.273809523809524; max_detected_n: 16; min_detected_n: 10
{'building ': 3804, ' tree ': 8640, ' clouds ': 3935, ' grasses ': 2661, ' sky ': 1065, ' hill ': 1033, ' monument ': 57, ' road ': 1194, ' path ': 1648, ' bench ': 721, ' bush ': 7995, ' pole ': 2280, ' lantern ': 90, ' signpost ': 3049, ' pointer ': 5286, ' sign': 3724}  
т.е. очень многие, минимум 62,5% встречаются на панорамах  

для отбора пусть будет 1 из 2 самых популярных 'building ': 3804, ' tree ': 8640  (классов, которые должны присутствовать на изображении, чтобы мы посчитали его подходящим для определения координат)  

**generate_vk_dataset.py** - отбираем из всех VK фотографий подходящие и копируем в соответствующий класс  
----------
нестабильно, путает и часто  

**geo_2.mobilenet.good-bad.teach.py, generate_vk_dataset_mnet.py** - обучаем модель разделять подходящие (похожие на панораму) и неподходящие фото  
Epoch 19 | Train Acc: 98.809532 | Train Loss: 0.050799 | Valid Acc: 96.666672 | Valid Loss: 0.077203  
detected_n: 6314; average_detected: 0.161499897687743;   

**geo_2.mobilenet.geo.teach.py** - обучение Mnet, аналогичное 01-GeoGuessr  
Epoch 100 | Train Acc: 91.665306 | Train Loss: 0.584837 | Valid Acc: 38.019482 | Valid Loss: 4.260039  
-----
видим явное переобучение  

**geo_2.mobilenet.vit.teach.py** - обучение ViT, аналогичное 01-GeoGuessr  
Epoch 6 | Train Acc: 77.695671 | Train Loss: 1.172473 | Valid Acc: 31.699139 | Valid Loss: 3.920901  
Epoch 100 | Train Acc: 98.713699 | Train Loss: 0.113396 | Valid Acc: 34.599571 | Valid Loss: 4.715114  
-----
видим явное переобучение  





### Вариант №2. Ищем самое похожее изображение по минимальному косинусному расстоянию. Классификация местности. Панорамы Yandex + VK / 04-Cosin

**generate_embds.py** - генерация эмббедингов изображений  
**test_accuracy.py** - тестирование точности  
images_n: 6522; accuracy_n: 31, accuracy: 0.004753 - reverse=True  
images_n: 6522; accuracy_n: 2793, accuracy: 0.428243  - reverse=False  
не отсекаем то-же самое изображение, просто тест на правильность самого подхода  
images_n: 6522; accuracy_n: 6503, accuracy: **0.997087**  

### Варианты №1+2. Исследование: сколько правильных ответов входит не в лучший класс, а в топ5. Классификация местности. Панорамы Yandex + VK / 05-Top5

**04_test_accuracy.py** - 04-Cosin  
images_n: 6522; accuracy_n: 3557, accuracy: 54.538485%  
**mnet.predict_top5.py** - 02-ClearDS, MNet  
top 5 session accuracy: 469 / 6522 = 7.1910%  
**vit.predict_top5.py** - 02-ClearDS, ViT  
top 5 session accuracy: 531 / 6522 = 8.141674%  
top 10 session accuracy: 824 / 6522 = 12.634161%  


### Вариант №6. Обучаем Gemma3. Классификация местности. Панорамы Yandex / 06-Gemma
https://www.kaggle.com/code/danielhanchen/gemma-3n-4b-multimodal-finetuning-inference  
**test_tramsform_ya.py** - тестирование и наладка: из панорам Yandex вырезаем и распознаем номера домов, название улиц. Вырезаем для того, чтобы модель не училась на этих данных. Номера домов ищем как цифры в фиолетовом овале  
**batch_ocr_yagpt_ya.py** - распознавание с помощью easyocr + валидация названия улицы на YaGPT. Доработан механизм вырезания и предобработки номера дома    
**gemma_3n_teach_ru.py** - обучение на русском языке -> выдает Яндекс Картак, надо и их вырезать  
!Ё!! Надо использовать именно FastModel, иначе ошибка при загрузке (.from_pretrained) обученной LoRa  

**batch_del_ya.py** - вырезаем "Открыть в Яндекс Картах"  

---- неудачные подходы
__batch_geocoder_ya.py__ - номера домов получаем из Геокодера -> ошибка в названиях файлов не позволяет получить координаты панорамы  
__batch_ocr_ya.py__ - распознавание только с помощью easyocr -> большое количество ошибок  
__batch_ya_2_en.py__ - перевод названий на английский -> имена собственные (улица Полевая) нельзя переводить (street Field)  
__batch_ya_2_trans.py__ - транслитерация названий на английский  
__gemma_3n_teach.py__ - обучение на английском  языке  
__old/gemma_3n-E4B_teach_ru.py__ - другие варианты Gemma 3  


### 08-Parse-NER. Парсинг социальных сетей (сайтов, Telegram-каналов и пр), выделение Geo NER для последующего обучения моделей ML

#### Подготовка ETL  
[Dagster | Туториал](https://habr.com/ru/articles/690342/)  

pip install dagster dagit  
cd D:\_gogs\kladez_v2\geo_osint_ml\08-Parse-NER  
dagster project scaffold --name geoosint  
cd geoosint  
pip install -e ".[dev]"  
--------
__**ToDo - глючит (ДАГ не подтягивается автоматически из assets), сложно. Надо разбираться**__




### etl - набор микросервисов для последовательной обработки новостей. Админка для верификации и ручной классификации

**0100_check_geo_good.py** - проверяем скачанные парсерами изображения на их пригодность для использования для определения местоположения. источник данных - ml_research/02-ClearDS/geo_2.mobilenet.good-bad.teach.py  
**0305_NER_hand.py** - разбиение текста на слова по пробелам для ручного выделения Geo NER  
**0310_NER_spacy_2.py** - модель Spacy ru_core_news_lg  


**0390_GeoGuessr_Hand_1.py** - добавление ручного типа классификации местности  

**0400_GeoGuessr_MNet_1.py** - определение класса местности, модель ml_research/02-ClearDS/geo_2.mobilenet.geo.teach.py  

**0450_GeoGuessr_ViT_Cos_1.py** - определение класса местности по минимальному косинусному расстоянию со всеми изображениями датасета, модель ViT-16b, разработка из ml_research/04-Cosin/   

**0500_Gemma_3.py** - генерация адресов по местности, разработка из ml_research/06-Gemma/   

**0600_K_Means_1.py** - среди всех классов, получившихся на предыдущих шагах, выделяем кластеры по географическому расположению и самый большой считаем правильным -> расчет перенесен в рантайм, router.py. В 0500_K_Means_1 остается только добавление типа процессинга.  

------
# Задача 7
Разработка программного обеспечения для определения характеристик состояния зеленых насаждений города по фотографиям  
**0700_Detect_Objects_1.py** - Детектирование требуемых объектов: деревьев, травы, кустарников, животных, насекомых, птиц. Модель: IDEA-Research/grounding-dino-base  

**0800_BioCLIP_1.py** - Классификация найденных объектов: деревьев, травы, кустарников, животных, насекомых, птиц.  

**0900_SanitarkaRu_1.py** - Используем Gemma 3 для определения наличия и описания вида санитарного повреждения дерева. Запрос на русском языке. Разработка из ml_research/10-Sanitarka. Модель unsloth/gemma-3n-E4B-it



-------- неудачные подходы  
__0300_NER_spacy_1.py__ - не совместима с текущей БД разные версии определения NER разбивают текст по разному, поэтому храним все разбиения, а не слова по отдельности  




